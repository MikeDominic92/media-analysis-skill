"""
Test Archival Workflow
Creates mock Phase 0 data and tests complete archival workflow

Tests:
1. Mock Phase 0 output creation
2. Archival script execution
3. Archive verification
4. Folder structure validation
5. File content validation
"""

import os
import json
import shutil
from pathlib import Path
from datetime import datetime


class ArchivalWorkflowTester:
    """Test complete archival workflow"""

    def __init__(self):
        self.tickets_dir = Path.home() / "Documents" / "tickets"
        self.processing_dir = self.tickets_dir / "processing"
        self.resolution_dir = self.tickets_dir / "resolution"
        self.test_ticket_id = "TEST123456"
        self.test_webedi_id = "TEST-999"
        self.test_company = "Test_Company"

    def setup_mock_phase0(self):
        """Create mock Phase 0 output"""
        print("\n[*] Setting up mock Phase 0 output...")

        # Create processing folder
        ticket_folder = self.processing_dir / self.test_ticket_id
        ticket_folder.mkdir(parents=True, exist_ok=True)

        # Create mock metadata.json
        metadata = {
            "ticket_id": self.test_ticket_id,
            "timestamp": datetime.now().isoformat(),
            "extraction_method": "gemini",
            "confidence": 0.92,
            "customer_name": "John Doe",
            "company": self.test_company,
            "webedi_id": self.test_webedi_id,
            "email": "john@testcompany.com",
            "phone": "(555) 123-4567",
            "trading_partner": "Test Partner",
            "transaction_type": "850",
            "issue_title": "Test EDI Issue",
            "issue_description": "This is a test EDI issue for archival workflow testing",
            "severity": "MEDIUM",
            "root_cause": "Test root cause for workflow verification",
            "recommended_actions": [
                "Test action 1",
                "Test action 2",
                "Test action 3"
            ]
        }

        metadata_file = ticket_folder / "metadata.json"
        with open(metadata_file, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, indent=2)

        print(f"    [+] Created {metadata_file}")

        # Create mock preliminary_analysis.md
        analysis_content = f"""# Preliminary Analysis - Ticket {self.test_ticket_id}

**Analysis Timestamp:** {datetime.now().isoformat()}
**Extraction Method:** Gemini 2.5 Pro
**Confidence Score:** 0.92 (HIGH)

## Customer Information

- **Name:** John Doe
- **Company:** {self.test_company}
- **Email:** john@testcompany.com
- **Phone:** (555) 123-4567

## Issue Summary

**Trading Partner:** Test Partner
**Transaction Type:** 850 (Purchase Order)
**Severity:** MEDIUM

**Issue Description:**
This is a test EDI issue for archival workflow testing.

## Initial Assessment

**Root Cause (Preliminary):**
Test root cause for workflow verification

## Recommended Actions

1. Test action 1
2. Test action 2
3. Test action 3

## Next Steps

- Proceed to Phase 1 (Analyst Agent extraction)
- Compare automated extraction to manual verification
- Continue investigation with NotebookLM queries

---

**Generated by:** Phase 0 Media Analysis (Gemini 2.5 Pro)
**For:** BMAD-EDI v4.0 Investigation Workflow
"""

        analysis_file = ticket_folder / "preliminary_analysis.md"
        with open(analysis_file, 'w', encoding='utf-8') as f:
            f.write(analysis_content)

        print(f"    [+] Created {analysis_file}")

        # Create mock ticket file (empty PDF for testing)
        ticket_filename = f"2025-10-29_{self.test_ticket_id}_{self.test_company}.pdf"
        ticket_file = ticket_folder / ticket_filename
        with open(ticket_file, 'w') as f:
            f.write("Mock PDF content for testing")

        print(f"    [+] Created {ticket_file}")
        print(f"\n[+] Mock Phase 0 setup complete")

        return ticket_folder

    def test_archival_script(self):
        """Test archival.py execution"""
        print("\n[*] Testing archival script...")

        # Import and run archival
        import sys
        sys.path.insert(0, str(Path(__file__).parent))

        from archival import ResolutionArchiver

        archiver = ResolutionArchiver(self.test_ticket_id)
        resolution_path = archiver.archive_resolution(self.test_webedi_id, self.test_company)

        print(f"\n[+] Archival script completed")
        print(f"    Resolution path: {resolution_path}")

        return Path(resolution_path)

    def verify_archive_structure(self, archive_path):
        """Verify archive structure"""
        print("\n[*] Verifying archive structure...")

        expected_structure = {
            "ticket_original": ["metadata.json"],
            "analysis": ["preliminary_analysis.md"],
            "customer_response": [],
            "verification": [],
            "": ["resolution_summary.md", "phase0_metrics.json"]
        }

        issues = []

        for subdir, expected_files in expected_structure.items():
            dir_path = archive_path / subdir if subdir else archive_path

            if not dir_path.exists() and subdir:
                issues.append(f"Missing directory: {subdir}/")
                print(f"    [X] {subdir}/ - MISSING")
            else:
                if subdir:
                    print(f"    [+] {subdir}/ - OK")

                for expected_file in expected_files:
                    file_path = dir_path / expected_file
                    if not file_path.exists():
                        issues.append(f"Missing file: {subdir}/{expected_file}")
                        print(f"    [X] {expected_file} - MISSING")
                    else:
                        print(f"    [+] {expected_file} - OK")

        # Check for original ticket file
        original_files = list((archive_path / "ticket_original").glob("*.pdf"))
        if not original_files:
            issues.append("No original ticket file found")
            print(f"    [X] Original ticket file - MISSING")
        else:
            print(f"    [+] Original ticket file - OK")

        if not issues:
            print(f"\n[+] Archive structure verification PASSED")
            return True
        else:
            print(f"\n[X] Archive structure verification FAILED")
            print(f"[!] Issues found:")
            for issue in issues:
                print(f"    - {issue}")
            return False

    def verify_file_contents(self, archive_path):
        """Verify file contents"""
        print("\n[*] Verifying file contents...")

        issues = []

        # Verify metadata.json
        metadata_file = archive_path / "ticket_original" / "metadata.json"
        if metadata_file.exists():
            try:
                with open(metadata_file, 'r', encoding='utf-8') as f:
                    metadata = json.load(f)

                required_fields = ["ticket_id", "extraction_method", "confidence"]
                for field in required_fields:
                    if field not in metadata:
                        issues.append(f"metadata.json missing field: {field}")

                print(f"    [+] metadata.json - Valid")
            except Exception as e:
                issues.append(f"metadata.json error: {str(e)}")
                print(f"    [X] metadata.json - Invalid")
        else:
            issues.append("metadata.json not found")
            print(f"    [X] metadata.json - Not found")

        # Verify resolution_summary.md
        summary_file = archive_path / "resolution_summary.md"
        if summary_file.exists():
            print(f"    [+] resolution_summary.md - OK")
        else:
            issues.append("resolution_summary.md not found")
            print(f"    [X] resolution_summary.md - Not found")

        # Verify phase0_metrics.json
        metrics_file = archive_path / "phase0_metrics.json"
        if metrics_file.exists():
            try:
                with open(metrics_file, 'r', encoding='utf-8') as f:
                    metrics = json.load(f)

                required_fields = ["ticket_id", "extraction_method", "confidence_score"]
                for field in required_fields:
                    if field not in metrics:
                        issues.append(f"phase0_metrics.json missing field: {field}")

                print(f"    [+] phase0_metrics.json - Valid")
            except Exception as e:
                issues.append(f"phase0_metrics.json error: {str(e)}")
                print(f"    [X] phase0_metrics.json - Invalid")
        else:
            issues.append("phase0_metrics.json not found")
            print(f"    [X] phase0_metrics.json - Not found")

        if not issues:
            print(f"\n[+] File contents verification PASSED")
            return True
        else:
            print(f"\n[X] File contents verification FAILED")
            print(f"[!] Issues found:")
            for issue in issues:
                print(f"    - {issue}")
            return False

    def test_verification_script(self, archive_path):
        """Test verify-archive.py"""
        print("\n[*] Testing verification script...")

        import sys
        sys.path.insert(0, str(Path(__file__).parent))

        from verify_archive import ArchiveVerifier

        verifier = ArchiveVerifier(self.test_webedi_id, self.test_company)
        results = verifier.verify()

        if results["archive_exists"] and results["structure_valid"] and results["phase0_complete"]:
            print(f"\n[+] Verification script PASSED")
            return True
        else:
            print(f"\n[X] Verification script FAILED")
            return False

    def cleanup(self):
        """Clean up test data"""
        print("\n[*] Cleaning up test data...")

        # Remove processing folder
        processing_folder = self.processing_dir / self.test_ticket_id
        if processing_folder.exists():
            shutil.rmtree(processing_folder)
            print(f"    [+] Removed {processing_folder}")

        # Remove resolution folder
        resolution_folder = self.resolution_dir / f"{self.test_webedi_id}_{self.test_company}"
        if resolution_folder.exists():
            shutil.rmtree(resolution_folder)
            print(f"    [+] Removed {resolution_folder}")

        print(f"\n[+] Cleanup complete")

    def run_full_test(self):
        """Run complete workflow test"""
        print("=" * 80)
        print("ARCHIVAL WORKFLOW TEST")
        print("=" * 80)

        try:
            # Step 1: Setup mock Phase 0
            ticket_folder = self.setup_mock_phase0()

            # Step 2: Test archival script
            archive_path = self.test_archival_script()

            # Step 3: Verify structure
            structure_ok = self.verify_archive_structure(archive_path)

            # Step 4: Verify contents
            contents_ok = self.verify_file_contents(archive_path)

            # Step 5: Test verification script
            verification_ok = self.test_verification_script(archive_path)

            # Summary
            print("\n" + "=" * 80)
            print("TEST SUMMARY")
            print("=" * 80)

            all_passed = structure_ok and contents_ok and verification_ok

            if all_passed:
                print("\n[+] ALL TESTS PASSED")
                print("\n[*] Archival workflow is working correctly:")
                print("    - Phase 0 artifacts archived")
                print("    - Folder structure created")
                print("    - Summary files generated")
                print("    - Verification successful")
            else:
                print("\n[X] SOME TESTS FAILED")
                print("\n[!] Issues detected:")
                if not structure_ok:
                    print("    - Archive structure issues")
                if not contents_ok:
                    print("    - File content issues")
                if not verification_ok:
                    print("    - Verification script issues")

            print("\n" + "=" * 80)

            # Cleanup prompt
            print("\n[?] Clean up test data? (y/n): ", end='')
            cleanup = input().strip().lower()
            if cleanup == 'y':
                self.cleanup()
            else:
                print(f"\n[*] Test data preserved at:")
                print(f"    Processing: {self.processing_dir / self.test_ticket_id}")
                print(f"    Resolution: {archive_path}")

            return all_passed

        except Exception as e:
            print(f"\n[X] Test failed with error: {str(e)}")
            import traceback
            traceback.print_exc()
            return False


def main():
    """Run workflow test"""
    tester = ArchivalWorkflowTester()
    success = tester.run_full_test()

    if success:
        print("\n[+] Archival workflow ready for production use")
        exit(0)
    else:
        print("\n[X] Archival workflow needs fixes before production use")
        exit(1)


if __name__ == "__main__":
    main()
